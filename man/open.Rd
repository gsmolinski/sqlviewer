% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/open.R
\name{open}
\alias{open}
\title{Run \code{sqlviewer} App}
\usage{
open(
  drv,
  ...,
  launch_browser = FALSE,
  app_host = "127.0.0.1",
  app_port = 49152
)
}
\arguments{
\item{drv}{database driver passed to \verb{[DBI::dbConnect()]}.}

\item{...}{other database driver arguments passed to \verb{[DBI::dbConnect()]}. See that function for details.}

\item{launch_browser}{launch browser when app starts? Must be logical length 1. Defaults to \code{FALSE}. Argument passed to \verb{[shiny::shinyApp()]}. Use \code{.rs.invokeShinyPaneViewer}
object as an argument to open in RStudio Viewer.}

\item{app_host}{IPv4 address (character vector length 1) on which application should listen on. Defaults to \code{"127.0.0.1"} (localhost). Argument passed to \verb{[shiny::shinyApp()]}.}

\item{app_port}{TCP port (integer vector length 1) on which application should listen on. Defaults to \code{49152}. Argument passed to \verb{[shiny::shinyApp()]}.}
}
\value{
Used for side effect - runs app.
}
\description{
Runs \code{shiny} application with the functionality provided by \code{sqlviewer}:
preview SQL queries and construct complex queries using solution inspired by pipe operator.
}
\details{
\code{sqlviewer} can be currently used only to retrieve data from DB, i.e. only \code{SELECT} queries are allowed (SQL code to run is passed to
\verb{[DBI::dbGetQuery()]}).

To run app in parallel mode (each query will be run in separate process), call \verb{[future::plan()]} with chosen strategy before
calling \code{sqlviewer::open()}. See \emph{Examples} and \emph{App Functionality} sections for more details.
}
\section{App Functionality}{

To insert query into app, copy-paste it to clipboard (it is possible to copy more than one query at a time, then more than one table will be displayed).
App will insert queries only if clipboard content changed from
previous insertion (e.g. if the same content is copied twice in a row, query won't be re-inserted). Each query must be named
and \strong{if some names of queries are duplicated, then app won't run}.

Switch button is used to indicate if clipboard should be observed. If set to off, then
no new queries will be created. To see result for chosen query, click on its name.
To copy query - click copy button - and to remove query, click remove button.
When query is removed, it is also copied to clipboard.

Each query is run in separate process using \verb{[shiny::ExtendedTask]} and when the query is running, app will not
allow to re-run the same query with the one exception - if the query was re-inserted to the app (copy-pasted again
to clipboard), then it will be possible to run this query - it will run in the new process, which means that previously
started query is still running. Unfortunately, it is impossible to kill process started by \verb{[shiny::ExtendedTask]} and if
one would need to do this, the only solution is to restart main R session.

\code{sqlviewer} displays only first 1000 rows of table.
}

\section{Labeling}{

Each SQL query needs to have label (name). Label \strong{has to be in its own line} (i.e. nothing more should exist in the same line except of intendation)
and have following format:
\preformatted{
-- #label
}
where instead of \code{label} should be unique query name (see \emph{Example} section below or \emph{Piping} section). \strong{To be valid, label must be
constructed using only: letters, numbers and underscores.}
Label can be used later for piping and will be used when displaying results of queries in the app.
}

\section{Piping}{

SQL queries can be very complex, especially when using nested queries. \code{sqlviewer} comes with the functionality to pipe one
labelled query into another query using \verb{|>} operator. Below is an example of how to pipe one query into another query:
\preformatted{
-- #all_species
SELECT i.Species
FROM iris i;

-- #filtered_data
SELECT *
FROM iris i
WHERE i.Species IN (
   -- |> all_species
   );
}
Pipe operator \strong{has to be in its own line} (i.e. nothing more should exist in the same line except indentation) and can be read as
"here put \emph{this} query". \code{sqlviewer} will analyze the code and insert labelled queries \emph{as-is} (query is not computed, just inserted)
in the line where pipe operator was used. It is not necessary to write queries from top to bottom, i.e. nested labelled query
can be below query into which this nested query will be piped.
}

\examples{

\dontrun{
temp_db <- fs::file_temp("sqlviewerDB_example", ext = ".db")
conn <- DBI::dbConnect(RSQLite::SQLite(), dbname = temp_db)
DBI::dbWriteTable(conn, "iris", iris)
DBI::dbDisconnect(conn)
future::plan("multisession") # run app in parallel mode
sqlviewer::open(RSQLite::SQLite(), dbname = temp_db)
# Now, copy SQL statement to clipboard (without comment signs!) and include label (-- #all_data)
#
# -- #all_data
# SELECT * FROM iris;
#
# and see result.
file.remove(temp_db)
}
}
